## Project Overview

Fiberus is an experimental project to build a new **native** [Haxe](https://haxe.org) compiler target with a fiber-based runtime for multiprocessing. It is designed specifically for workloads that can benefit from **native, lightweight, cooperative concurrency** using [fibers/coroutines](https://graphitemaster.github.io/fibers/#what-are-fibers) combined with a **work-stealing scheduler** and tight GC integration.

Fiberus exists to let you write clean, idiomatic [Haxe code](https://haxe.org/documentation/introduction/language-introduction.html) while enjoying cooperative concurrency that feels like a natural part of the language and runtime - without the friction of high-level async/await constructs that always seemed like an afterthought layered on top in other languages and runtimes.

### Target Use Cases

1. **High-concurrency task-parallel applications** - Breaking work into thousands of small, independent jobs (e.g., ray tracing, physics simulation, build pipelines, data processing)
2. **Game engines and real-time systems** - Inspired by the [Naughty Dog fiber model (GDC 2015 talk)](https://gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine)
3. **Server-side applications with massive concurrency** - Web servers, game servers, chat systems
4. **Embarrassingly parallel compute workloads** - Raytracers, video encoders, scientific simulations
5. **Scenarios where preemptive threads are problematic** - Avoiding priority inversion, thread starvation, or complex mutex hierarchies

---

### Project Status

| Metric | Value |
|--------|-------|
| **Haxe Std Library Parity** | ~95-97% with hxcpp |
| **Haxe Unit Tests** | 11,032 assertions — 0 failures |
| **Fiberus Native Tests** | ~1,607 assertions — all passing |
| **Combined Test Coverage** | ~12,639 assertions |
| **Codebase** | ~65,300 lines across ~186 files |
| **Platform** | Linux x86_64 only |

(Same Haxe unit test suite used by hxcpp, HashLink, and JVM targets.)

**What works today:**
- Full fiber spawn/yield/context switching (hand-written x86-64 assembly)
- Work-stealing multi-threaded scheduler (Chase-Lev deque)
- Generational garbage collection (Fibrix with nursery/mature generations)
- io_uring async I/O — fibers yield instead of blocking threads
- SSL/TLS via mbedTLS with io_uring-integrated BIO
- HTTP/HTTPS client, TCP/UDP sockets
- SQLite with custom VFS routing I/O through io_uring (non-blocking)
- Full runtime reflection and type introspection (Reflect, Type)
- SIMD-accelerated JSON parsing (simdjson), UTF-8 (simdutf), regex (pcre2)
- Crypto: Md5, Sha1, Sha256, Base64, Crc32, Adler32
- Subprocess management with pidfd + io_uring for fiber-friendly waiting
- Collections, pattern matching, enums, generics, closures, exception handling

---

### Fiberus in action
A [simple webserver written in Haxe running fiberus](https://gist.github.com/dazKind/163137765d166a98df68f073d52b8d24), spawning a fiber for every request ([Loadtest Results](https://gist.github.com/dazKind/2483162f05da0194fceaac6d73537bd7)).

The still unoptimized garbage collector's major STW collections clearly visible via Tracy-Profiler:

<img width="764" height="745" alt="image" src="https://github.com/user-attachments/assets/c9d07aab-2b14-4419-8dcb-a06c5184bbb6" />

---
### Fiberus Architecture Overview

- **Cooperative Fibers**  
  Lightweight, user-space coroutines with dedicated per-fiber stacks (guard pages + buffer zones for overflow safety). Context switching is implemented in hand-written x86-64 assembly for minimal overhead, enabling millions of concurrent fibers without kernel thread blocking.

- **Lock-Free Work-Stealing Scheduler**  
  Multi-threaded task distribution using the Chase-Lev dynamic circular work-stealing deque. Owner operations (push/pop) are wait-free; steal operations are lock-free. Integrated GC-safe scanning of deques and last-popped fibers ensures correctness during stop-the-world pauses.

- **Targeted Fiber Spawning**  
  In addition to opportunistic work-stealing, fibers can explicitly route new child fibers to the inbox of any chosen thread. This enables thread affinity, load balancing hints, or actor-style message passing while preserving the lock-free, high-throughput nature of the scheduler.

- **Fibrix Garbage Collector**  
  A novel fiber-aware, generational collector inspired by Immix and Naughty Dog’s GDC 2015 design:  
  - Per-thread nurseries with Cheney-style evacuating minor collections and write barriers  
  - Mature space using 2 MiB superblocks (64 × 32 KB blocks) and per-thread bump-pointer caches  
  - Precise root tracking via explicit temp-root pushes generated by the compiler  
  - Conservative fiber stack scanning with tracked bounds  

- **io_uring-Based Non-Blocking I/O**  
  Per-thread io_uring instances drive asynchronous file and network operations. I/O completion wakes the waiting fiber directly, keeping threads fully utilized. Pending I/O requests are tracked as GC roots, and the design integrates with the Counter primitive for composable async patterns.


